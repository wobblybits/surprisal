<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Coiny&family=Fredoka:wght@300..700&family=Major+Mono+Display&family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Offside&family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../assets/css/styles.css">
    <title>Surprisal Calculator</title>
    <script src="https://unpkg.com/tone"></script>
    <script type="module">
      import { presets, scaleIntervals, notes, models } from "../assets/js/config.js";

      // ============================================================================
      // ERROR HANDLING - Simple, reusable error utilities
      // ============================================================================
      const ErrorHandler = {
        showError: (message, duration = 5000) => {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error-message';
          errorDiv.textContent = message;
          errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff4444;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-family: 'Fredoka', sans-serif;
          `;
          document.body.appendChild(errorDiv);
          
          setTimeout(() => {
            if (errorDiv.parentNode) {
              errorDiv.parentNode.removeChild(errorDiv);
            }
          }, duration);
        },

        logError: (error, context = '') => {
          const errorMessage = context ? `${context}: ${error.message || error}` : error.message || error;
          console.error(errorMessage);
          if (error.stack) {
            console.error(error.stack);
          }
        },

        validateInput: (text) => {
          if (!text || typeof text !== 'string') {
            throw new Error('Text input is required and must be a string');
          }
          if (text.trim().length === 0) {
            throw new Error('Text input cannot be empty');
          }
          if (text.length > 1000) {
            throw new Error('Text input is too long (maximum 1000 characters)');
          }
          return text.trim();
        },

        validateData: (data) => {
          if (!data || typeof data !== 'object') {
            throw new Error('Invalid data received from server');
          }
          if (!Array.isArray(data.surprisals)) {
            throw new Error('Invalid surprisals data received');
          }
          if (!Array.isArray(data.lengths)) {
            throw new Error('Invalid lengths data received');
          }
          if (!Array.isArray(data.frequencies_inverted)) {
            throw new Error('Invalid frequencies data received');
          }
          return data;
        },

        // Enhanced error handling with async function wrapper
        wrapAsyncFunction(fn, context) {
          return async (...args) => {
            try {
              return await fn(...args);
            } catch (error) {
              this.logError(error, context);
              this.showError(`Operation failed: ${error.message}`);
              throw error; // Re-throw for calling code to handle if needed
            }
          };
        },

        // Global error handler for uncaught errors
        setupGlobalErrorHandling() {
          window.addEventListener('error', (event) => {
            this.logError(event.error, 'Global error');
            this.showError('An unexpected error occurred');
          });

          window.addEventListener('unhandledrejection', (event) => {
            this.logError(event.reason, 'Unhandled promise rejection');
            this.showError('A background operation failed');
          });
        }
      };

      // ============================================================================
      // VALIDATION UTILITIES - Input sanitization and validation
      // ============================================================================
      const ValidationUtils = {
        sanitizeText(text) {
          return text
            .trim()
            .replace(/[<>]/g, '') // Remove potential HTML
            .substring(0, 1000);  // Limit length
        },

        validateScaleSelection(scaleName) {
          if (!state.scales[scaleName]) {
            throw new Error(`Invalid scale: ${scaleName}`);
          }
          return true;
        },

        validateModelSelection(modelName) {
          if (!models.includes(modelName)) {
            throw new Error(`Invalid model: ${modelName}`);
          }
          return true;
        },

        validateInstrumentSelection(instrumentName) {
          if (!presets[instrumentName]) {
            throw new Error(`Invalid instrument: ${instrumentName}`);
          }
          return true;
        }
      };

      // ============================================================================
      // PERFORMANCE UTILITIES - Debouncing and throttling
      // ============================================================================
      const PerformanceUtils = {
        debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },

        throttle(func, limit) {
          let inThrottle;
          return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
              func.apply(context, args);
              inThrottle = true;
              setTimeout(() => inThrottle = false, limit);
            }
          };
        }
      };

      // ============================================================================
      // ACCESSIBILITY UTILITIES - Screen reader and keyboard navigation
      // ============================================================================
      const AccessibilityUtils = {
        addKeyboardNavigation() {
          // Add tab navigation to custom buttons
          document.querySelectorAll('#scales div, #models div, #instruments div').forEach(button => {
            button.setAttribute('tabindex', '0');
            button.setAttribute('role', 'button');
            button.setAttribute('aria-label', button.textContent || button.id);
            
            // Add keyboard event handlers
            button.addEventListener('keydown', (event) => {
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                button.click();
              }
            });
          });
        },

        announceToScreenReader(message) {
          const announcement = document.createElement('div');
          announcement.setAttribute('aria-live', 'polite');
          announcement.setAttribute('aria-atomic', 'true');
          announcement.className = 'sr-only';
          announcement.textContent = message;
          document.body.appendChild(announcement);
          setTimeout(() => announcement.remove(), 1000);
        },

        updateAriaLabels() {
          // Update keyboard keys with proper labels
          document.querySelectorAll('#keyboard div').forEach(key => {
            const note = key.id;
            const isDisabled = key.classList.contains('disabled');
            key.setAttribute('aria-label', `${note} note${isDisabled ? ' (disabled)' : ''}`);
            key.setAttribute('role', 'button');
            key.setAttribute('tabindex', isDisabled ? '-1' : '0');
          });
        }
      };

      // ============================================================================
      // STATE MANAGEMENT - Simple object to track current settings
      // ============================================================================
      const state = {
        currentSettings: ["THEREMIN", "MAJOR-7", "GPT2"],
        currentScale: null,
        currentVector: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        scales: {},
        toneOutput: null,
        isLoading: false,
        
        updateSettings(newSettings) {
          this.currentSettings = newSettings;
          this.updateIndicator();
        },
        
        updateIndicator() {
          const indicator = document.getElementById('indicator');
          if (indicator) {
            // Create a copy of currentSettings and crop the model name (index 2) to 10 characters
            const displaySettings = this.currentSettings.map((setting, index) => {
              if (index === 2) { // Model name is at index 2
                return setting.split(" ").pop();
              }
              return setting;
            });
            indicator.innerHTML = "<span>" + displaySettings.join('</span><span>') + "</span>";
          }
        },

        // Initialize scales first so currentScale can be set properly
        initScales() {
          const scaleGroups = Object.keys(scaleIntervals);
          for (const group of scaleGroups) {
            this.scales = {...this.scales, ...scaleIntervals[group]};
          }
          this.currentScale = Object.keys(this.scales)[0];
        },

        setLoading(loading) {
          this.isLoading = loading;
          if (loading) {
            ui.showLoading();
          } else {
            ui.hideLoading();
          }
        }
      };

      // ============================================================================
      // AUDIO FUNCTIONS - All the music-making logic
      // ============================================================================
      const audio = {
        synth: null,
        sampler: null,
        
        init() {
          this.synth = new Tone.Synth().toDestination();
          this.synth.volume.value = 0.5;
          this.sampler = new Tone.Sampler({
            urls: { "A3": "assets/audio/meow.mp3" }
          }).toDestination();
          state.toneOutput = this.synth;
          this.synth.set(presets["theremin"]);
          Tone.Transport.start(0);
        },

        async playMelody(data) {
          try {
            await Tone.start();
            const surprisals = data.surprisals;
            let pitches = [];
            let notes = [];
            
            if (state.currentScale === "continuous") {
              pitches = this.convertToContinuous(surprisals);
              notes = pitches;
            } else {
              pitches = this.convertToScale(surprisals);
              notes = pitches.map(d => Tone.Frequency("C3").transpose(d));
            }
            
            const durations = data.lengths;
            const volumes = data.frequencies_inverted;
            let delay = Tone.now();
            const offset = delay;
            const timeouts = [];

            const userInput = document.getElementById('user-input');
            if (!userInput) {
              throw new Error('User input element not found');
            }

            let startIndex = 0;
            let endIndex = 0;

            for (let i = 0; i < surprisals.length; i++) {
              timeouts.push(delay);
              endIndex = startIndex + durations[i];
              const startPos = startIndex;
              const endPos = endIndex;
              durations[i] /= 8;
              state.toneOutput.volume.value = volumes[i] / 8;
              
              state.toneOutput.triggerAttackRelease(notes[i], durations[i], delay);  
              window.setTimeout(() => {
                try {
                  const key = document.getElementById(this.convertSharpToFlat(notes[i].toNote()));
                  if (key) {
                    key.classList.add("highlight");
                  }
                  userInput.setSelectionRange(startPos, endPos);
                  userInput.focus();
                  window.setTimeout(() => {
                    try {
                      userInput.blur();
                      userInput.setSelectionRange(0, 0);
                      if (key) {
                        key.classList.remove("highlight");
                      }
                    } catch (error) {
                      ErrorHandler.logError(error, 'playMelody cleanup');
                    }
                  }, Tone.Time(durations[i]).toSeconds() * 900);
                } catch (error) {
                  ErrorHandler.logError(error, 'playMelody highlight');
                }
              }, (Tone.Time(timeouts[i]).toSeconds() - offset) * 1000);
              delay += durations[i];
              startIndex = endIndex;
            }
          } catch (error) {
            ErrorHandler.logError(error, 'playMelody');
            ErrorHandler.showError(`Failed to play melody: ${error.message}`);
          }
        },

        convertToScale(surprisals) {
          try {
            if (!Array.isArray(surprisals)) {
              throw new Error('Surprisals must be an array');
            }
            if (!state.currentScale || !state.scales[state.currentScale] || !Array.isArray(state.scales[state.currentScale])) {
              throw new Error('Invalid scale configuration');
            }

            const convertedPitches = [];
            for (let i = 0; i < surprisals.length; i++) {
              if (typeof surprisals[i] !== 'number' || isNaN(surprisals[i])) {
                throw new Error('Surprisals must contain valid numbers');
              }
              const interval = Math.round(surprisals[i] / 2);
              const scaleLength = state.scales[state.currentScale].length;
              if (interval > scaleLength - 1) {
                convertedPitches.push(state.scales[state.currentScale][scaleLength - 1]);
              } else {
                convertedPitches.push(state.scales[state.currentScale][interval]);
              }
            }
            return convertedPitches;
          } catch (error) {
            ErrorHandler.logError(error, 'convertToScale');
            ErrorHandler.showError(`Failed to convert to scale: ${error.message}`);
            return [];
          }
        },

        convertToContinuous(surprisals) {
          try {
            if (!Array.isArray(surprisals)) {
              throw new Error('Surprisals must be an array');
            }

            const convertedPitches = [];
            for (let i = 0; i < surprisals.length; i++) {
              if (typeof surprisals[i] !== 'number' || isNaN(surprisals[i])) {
                throw new Error('Surprisals must contain valid numbers');
              }
              const newPitch = Math.pow(2, (48 + surprisals[i] / 2 - 69) / 12) * 440;
              convertedPitches.push(newPitch.toString());
            }
            // set first note to c3 since 0hz isn't audible
            convertedPitches[0] = 130; 
            return convertedPitches;
          } catch (error) {
            ErrorHandler.logError(error, 'convertToContinuous');
            ErrorHandler.showError(`Failed to convert to continuous: ${error.message}`);
            return [];
          }
        },

        convertSharpToFlat(note) {
          try {
            if (!note || typeof note !== 'string') {
              throw new Error('Note must be a valid string');
            }
            if (note.indexOf("#") === 1) {
              const noteIndex = notes.indexOf(note[0]);
              if (noteIndex === -1 || noteIndex + 1 >= notes.length) {
                throw new Error('Invalid note format');
              }
              return notes[noteIndex + 1] + note[2];
            }
            return note;
          } catch (error) {
            ErrorHandler.logError(error, 'convertSharpToFlat');
            return note; // Return original note if conversion fails
          }
        },

        convertFlatToSymbol(note) {
          try {
            if (!note || typeof note !== 'string') {
              return note;
            }
            return note.replace("b", "&flat;");
          } catch (error) {
            ErrorHandler.logError(error, 'convertFlatToSymbol');
            return note;
          }
        }
      };

      // ============================================================================
      // API FUNCTIONS - Backend communication
      // ============================================================================
      const api = {
        async fetchFromBackend(text) {
          try {
            const cleanText = ValidationUtils.sanitizeText(text);
            const validatedText = ErrorHandler.validateInput(cleanText);
            
            state.setLoading(true);
            
            // Get current model from state (convert to lowercase for API)
            const currentModel = state.currentSettings[2].toLowerCase();
            
            const response = await fetch('/process/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                text: validatedText,
                model: currentModel
              })
            });

            if (!response.ok) {
              throw new Error(`Server error: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            const validatedData = ErrorHandler.validateData(data);
            await audio.playMelody(validatedData);
            
            AccessibilityUtils.announceToScreenReader('Melody composed successfully');
            
          } catch (error) {
            ErrorHandler.logError(error, 'fetchFromBackend');
            ErrorHandler.showError(`Failed to process text: ${error.message}`);
            AccessibilityUtils.announceToScreenReader('Failed to compose melody');
          } finally {
            state.setLoading(false);
          }
        },

        async fetchFromBackendReverse(text, scalePitch) {
          try {
            if (!state.currentScale || !state.scales[state.currentScale] || !Array.isArray(state.scales[state.currentScale])) {
              throw new Error('Invalid scale configuration');
            }

            const interval = state.scales[state.currentScale].indexOf(scalePitch);
            if (interval === -1) {
              throw new Error('Invalid scale pitch');
            }

            const cleanText = ValidationUtils.sanitizeText(text);
            
            // Get current model from state (convert to lowercase for API)
            const currentModel = state.currentSettings[2].toLowerCase();
            
            const response = await fetch('/reverse/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                text: cleanText, 
                note: interval,
                model: currentModel
              })
            });

            if (!response.ok) {
              throw new Error(`Server error: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            if (!data || typeof data.input_text !== 'string' || typeof data.best_token !== 'string') {
              throw new Error('Invalid response data from server');
            }

            const userInput = document.getElementById('user-input');
            if (!userInput) {
              throw new Error('User input element not found');
            }

            const currentText = userInput.value;
            const newText = data.input_text + data.best_token;
            userInput.value = newText;
            userInput.setSelectionRange(data.input_text.length, data.input_text.length + data.best_token.length);
            userInput.focus();
            userInput.blur();
            
            AccessibilityUtils.announceToScreenReader('Text generated successfully');
            
          } catch (error) {
            ErrorHandler.logError(error, 'fetchFromBackendReverse');
            ErrorHandler.showError(`Failed to generate text: ${error.message}`);
            AccessibilityUtils.announceToScreenReader('Failed to generate text');
          }
        }
      };

      // ============================================================================
      // UI FUNCTIONS - All the interface interactions
      // ============================================================================
      const ui = {
        init() {
          // Initialize scales first, then everything else
          state.initScales();
          this.setupInstruments();
          this.setupScales();
          this.setupModels();
          this.setupKeyboard();
          this.setupExamples();
          this.setupSubmitButton();
          this.setupKeyboardEvents();
          this.setupAccessibility();
        },

        showLoading(message = 'Processing...') {
          const loadingDiv = document.createElement('div');
          loadingDiv.id = 'loading';
          loadingDiv.innerHTML = `
            <div class="loading-spinner"></div>
            <div class="loading-text">${message}</div>
          `;
          loadingDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
            text-align: center;
            font-family: 'Fredoka', sans-serif;
          `;
          
          // Add spinner CSS
          const spinnerCSS = `
            .loading-spinner {
              width: 40px;
              height: 40px;
              border: 4px solid #f3f3f3;
              border-top: 4px solid #3498db;
              border-radius: 50%;
              animation: spin 1s linear infinite;
              margin: 0 auto 10px;
            }
            @keyframes spin {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }
          `;
          
          if (!document.getElementById('loading-styles')) {
            const styleSheet = document.createElement('style');
            styleSheet.id = 'loading-styles';
            styleSheet.textContent = spinnerCSS;
            document.head.appendChild(styleSheet);
          }
          
          document.body.appendChild(loadingDiv);
        },

        hideLoading() {
          const loading = document.getElementById('loading');
          if (loading) {
            loading.remove();
          }
        },

        setupAccessibility() {
          AccessibilityUtils.addKeyboardNavigation();
          AccessibilityUtils.updateAriaLabels();
        },

        setupInstruments() {
          const instrumentContainer = document.getElementById("instruments");
          if (!instrumentContainer) {
            ErrorHandler.logError('Instrument container not found', 'initialization');
            return;
          }

          const instruments = Object.keys(presets);
          for (const instrumentName of instruments) {
            try {
              const button = document.createElement("div");
              button.id = instrumentName;
              button.innerHTML = "<img src='assets/images/instruments/" + instrumentName + ".png' />";
              button.onclick = (event) => {
                try {
                  ValidationUtils.validateInstrumentSelection(instrumentName);
                  
                  const instrument = button.id;
                  const preset = presets[instrument];
                  if (instrument === "cat") {
                    state.toneOutput = audio.sampler;
                  } else {
                    state.toneOutput = audio.synth;
                    state.toneOutput.set(preset);
                  }
                  state.currentSettings[0] = instrument.toUpperCase();
                  state.updateIndicator();
                  
                  AccessibilityUtils.announceToScreenReader(`Switched to ${instrument} instrument`);
                  
                } catch (error) {
                  ErrorHandler.logError(error, 'instrument selection');
                  ErrorHandler.showError(`Failed to select instrument: ${error.message}`);
                }
              };
              instrumentContainer.appendChild(button);
            } catch (error) {
              ErrorHandler.logError(error, 'instrument creation');
            }
          }
        },

        setupScales() {
          const scalesContainer = document.getElementById("scales");
          if (!scalesContainer) {
            ErrorHandler.logError('Scales container not found', 'initialization');
            return;
          }

          for (const groupName in scaleIntervals) {
            try {
              const group = document.createElement("div");
              group.id = groupName;
              for (const scaleName in scaleIntervals[groupName]) {     
                const button = document.createElement("div");
                button.id = scaleName;
                button.innerHTML = scaleName.split("-")[0];
                button.onclick = (event) => {
                  try {
                    ValidationUtils.validateScaleSelection(scaleName);
                    
                    const selectedScale = button.id;
                    const intervals = state.scales[selectedScale];
                    state.currentScale = selectedScale;
                    state.currentSettings[1] = selectedScale.toUpperCase();
                    state.updateIndicator();
                    
                    document.querySelectorAll("#keyboard div").forEach((key, index) => {
                      if (state.scales[selectedScale].includes(index)) {
                        key.classList.remove("disabled");
                      } else {
                        key.classList.add("disabled");
                      }
                    });
                    
                    AccessibilityUtils.updateAriaLabels();
                    AccessibilityUtils.announceToScreenReader(`Switched to ${selectedScale} scale`);
                    
                  } catch (error) {
                    ErrorHandler.logError(error, 'scale selection');
                    ErrorHandler.showError(`Failed to select scale: ${error.message}`);
                  }
                };
                group.appendChild(button);
              }
              scalesContainer.appendChild(group);
            } catch (error) {
              ErrorHandler.logError(error, 'scale creation');
            }
          }
        },

        setupModels() {
          const modelsContainer = document.getElementById("models");
          if (!modelsContainer) {
            ErrorHandler.logError('Models container not found', 'initialization');
            return;
          }

          for (const modelName of models) {
            try {
              const button = document.createElement("div");
              button.id = modelName;
              button.innerHTML = modelName;
              button.onclick = async (event) => {
                try {
                  ValidationUtils.validateModelSelection(modelName);
                  
                  const selectedModel = button.id;
                  state.currentSettings[2] = selectedModel.toUpperCase();
                  state.updateIndicator();
                  
                  // Remove the model switching API call - no longer needed!
                  // Just update the UI state
                  AccessibilityUtils.announceToScreenReader(`Switched to ${selectedModel} model`);
                  
                } catch (error) {
                  ErrorHandler.logError(error, 'model selection');
                  ErrorHandler.showError(`Failed to select model: ${error.message}`);
                }
              };
              modelsContainer.appendChild(button);
            } catch (error) {
              ErrorHandler.logError(error, 'model creation');
            }
          }
        },

        setupKeyboard() {
          const pianoContainer = document.getElementById("keyboard");
          if (!pianoContainer) {
            ErrorHandler.logError('Piano container not found', 'initialization');
            return;
          }

          const startingNote = "C";
          const startingPitch = notes.indexOf(startingNote);
          const startingOctave = 3;
          let spacing = 0;
          const numOctaves = 2;
          const numKeysPastOctave = 0;
          
          for (let i = 0; i < numOctaves * 12 + numKeysPastOctave; i++) {
            try {
              const key = document.createElement("div");
              const note = notes[(i + startingPitch) % notes.length];
              key.id = note + (startingOctave + Math.floor(i / 12));
              const scalePitch = i;
              if (note.length > 1) {
                key.style.bottom = (100 * (spacing - 0.5) / (numOctaves * 7 + numKeysPastOctave)) + "%";
                key.classList.add("black-key");
              } else {
                key.style.bottom = (100 * spacing / (numOctaves * 7 + numKeysPastOctave)) + "%";
                key.classList.add("white-key");
                spacing++;
              }
              key.innerHTML = audio.convertFlatToSymbol(key.id);
              if (state.scales[state.currentScale] && state.scales[state.currentScale].includes(i)) {
                  key.classList.remove("disabled");
              } else {
                  key.classList.add("disabled");
              }
              key.onclick = (event) => {
                try {
                  state.toneOutput.triggerAttackRelease(key.id, "8n", Tone.now());
                  const text = document.getElementById("user-input").value;
                  api.fetchFromBackendReverse(text, scalePitch);
                } catch (error) {
                  ErrorHandler.logError(error, 'key click');
                  ErrorHandler.showError(`Failed to play key: ${error.message}`);
                }
              };
              pianoContainer.appendChild(key);
            } catch (error) {
              ErrorHandler.logError(error, 'key creation');
            }
          }
        },

        setupSubmitButton() {
          const submitButton = document.getElementById("submit");
          if (submitButton) {
            submitButton.onclick = (event) => {
              try {
                const text = document.getElementById("user-input").value;
                api.fetchFromBackend(text);
              } catch (error) {
                ErrorHandler.logError(error, 'submit button');
                ErrorHandler.showError(`Failed to submit: ${error.message}`);
              }
            };
          }
        },

        setupKeyboardEvents() {
          const lastKeyPress = {
            key: null,
            time: null,
            note: null,
          };
          
          // Debounced key handling for better performance
          const debouncedKeyHandler = PerformanceUtils.debounce((key, action) => {
            try {
              if (document.activeElement.id === "user-input") {
                return;
              }
              if (lastKeyPress.key !== key && parseInt(key) > 0 && parseInt(key) < 10) {
                if (lastKeyPress.key !== null) {
                  const text = document.getElementById("user-input").value;
                  api.fetchFromBackendReverse(text, state.scales[state.currentScale][parseInt(lastKeyPress.key) - 1]);
                  const keyElement = document.getElementById(audio.convertSharpToFlat(lastKeyPress.note.toNote()));
                  if (keyElement) {
                    keyElement.classList.remove("highlight");
                  }
                }
                lastKeyPress.key = key;
                lastKeyPress.time = performance.now();
                const pitch = audio.convertToScale([(parseInt(key) - 1) * 2]);
                const note = Tone.Frequency("C3").transpose(pitch);
                lastKeyPress.note = note;
                state.toneOutput.triggerAttackRelease(note, "8n", Tone.now());
                const keyElement = document.getElementById(audio.convertSharpToFlat(lastKeyPress.note.toNote()));
                if (keyElement) {
                  keyElement.classList.add("highlight");
                }
              } else if (action === 'up' && lastKeyPress.key === key) {
                const text = document.getElementById("user-input").value;
                api.fetchFromBackendReverse(text, state.scales[state.currentScale].indexOf(parseInt(key) - 1));
                const keyElement = document.getElementById(audio.convertSharpToFlat(lastKeyPress.note.toNote()));
                if (keyElement) {
                  keyElement.classList.remove("highlight");
                }
                lastKeyPress.key = null;
                lastKeyPress.time = null;
              }
            } catch (error) {
              ErrorHandler.logError(error, 'keyboard event handling');
            }
          }, 50); // 50ms debounce
          
          window.onkeydown = (event) => {
            try {
              if (document.activeElement.id === "user-input") {
                return;
              }
              if (lastKeyPress.key !== event.key && parseInt(event.key) > 0 && parseInt(event.key) < 10) {
                debouncedKeyHandler(event.key, 'down');
              }
            } catch (error) {
              ErrorHandler.logError(error, 'keydown');
            }
          };
          
          window.onkeyup = (event) => {
            try {
              if (document.activeElement.id === "user-input" || lastKeyPress.key === null) {
                return;
              }
              if (lastKeyPress.key === event.key) {
                debouncedKeyHandler(event.key, 'up');
              }
            } catch (error) {
              ErrorHandler.logError(error, 'keyup');
            }
          };
        },

        setupExamples() {
          document.getElementById("ex1")?.addEventListener("click", function() {
            try {
              document.getElementById("ex1_hidden")?.classList.remove("hiding");
              document.getElementById("ex1")?.classList.add("hiding");
            } catch (error) {
              ErrorHandler.logError(error, 'ex1 click');
            }
          });
          
          document.getElementById("ex2")?.addEventListener("click", function() {
            try {
              document.getElementById("ex2_hidden")?.classList.remove("hiding");
              document.getElementById("ex2")?.classList.add("hiding");
            } catch (error) {
              ErrorHandler.logError(error, 'ex2 click');
            }
          });
          
          document.getElementById("ex1_hidden")?.addEventListener("click", function() {
            try {
              document.getElementById("ex1_hidden")?.classList.add("hiding");
              document.getElementById("ex1")?.classList.remove("hiding");
            } catch (error) {
              ErrorHandler.logError(error, 'ex1_hidden click');
            }
          });
          
          document.getElementById("ex2_hidden")?.addEventListener("click", function() {
            try {
              document.getElementById("ex2_hidden")?.classList.add("hiding");
              document.getElementById("ex2")?.classList.remove("hiding");
            } catch (error) {
              ErrorHandler.logError(error, 'ex2_hidden click');
            }
          });

          document.getElementById("ex1_demo")?.addEventListener("click", function() { 
            try {
              const userInput = document.getElementById("user-input");
              if (userInput) {
                userInput.value = "the man fed the cat some tuna.";
                const text = userInput.value;
                api.fetchFromBackend(text);
                window.scrollTo({
                  top: 0,
                  behavior: "smooth"
                });
              }
            } catch (error) {
              ErrorHandler.logError(error, 'ex1_demo click');
              ErrorHandler.showError(`Failed to load example: ${error.message}`);
            }
          });

          document.getElementById("ex2_demo")?.addEventListener("click", function() { 
            try {
              const userInput = document.getElementById("user-input");
              if (userInput) {
                userInput.value = "the lawyer presented the cat with a lawsuit.";
                const text = userInput.value;
                api.fetchFromBackend(text);
                window.scrollTo({
                  top: 0,
                  behavior: "smooth"
                });
              }
            } catch (error) {
              ErrorHandler.logError(error, 'ex2_demo click');
              ErrorHandler.showError(`Failed to load example: ${error.message}`);
            }
          });
        }
      };

      // ============================================================================
      // MAIN INITIALIZATION - Everything comes together here
      // ============================================================================
      window.onload = () => {
        // Initialize scales first, then audio, then UI
        state.initScales();
        audio.init();
        ui.init();
        state.updateIndicator();
        
        // Setup global error handling
        ErrorHandler.setupGlobalErrorHandling();
      };
    </script>
  </head>
  <body>
    <div id="container">
      <div id="calculator">
        <div id="title">WM7<span style="font-size: .8em; font-family: portfolio">±</span>2</div>
        <div id="display">
          <div id="indicator"></div> 
          <textarea id="user-input" placeholder="Enter text here..."></textarea>
        </div>
        <div id="buttons">
          <div id="scales"></div>
          <div id="models"></div>
          <div id="instruments"></div>
          <div id="translate">
            <div id="submit">Compose ♫</div>
          </div>
        </div>
      </div>
      <div id="keyboard"></div>
    </div>
    <div id="explainer">
      <h1 id="heading">
        The Surprisal Calculator WM7±2
      </h1>
      <h4>Made by David Feil and Elise Kim during a batch at the Recurse Center. <script async defer src="https://www.recurse-scout.com/loader.js?t=62e333ccfa9ade523f73c9755aa46503"></script></h4>

        <p>On this page, we invite you to experiment with the <strong>Surprisal Calculator WM 7±2</strong>, a tool developed to turn the flow of information in human language into melodies. According to <strong>surprisal theory</strong>, the more surprising a sentence is, the longer it takes for the human brain to understand. To see this in action, consider the two sentences below:</p> 

        <div id="examples">
          <div class="example-wrapper">
            <div id="ex1" class="example"> CLICK: sentence 1</div>
            <div id="ex1_hidden" class="example hiding"> The man fed the <strong>cat</strong> some tuna.</div>
          </div>
          <div class="example-wrapper">
            <div id="ex2" class="example"> CLICK: sentence 2</div>
            <div id="ex2_hidden" class="example hiding"> The lawyer presented the <strong>cat</strong> with a lawsuit.</div>
          </div>
        </div>

        <p>Even though the word <em>cat</em> appears in both sentences, it's far more surprising in the context of the second sentence. Odds are that the second sentence also took you longer to process.</p>
        <p>This seemingly fuzzy notion of "surprisingness" can actually be quantified using a formula first developed by Claude Shannon, the father of information theory. An event's surprisal is calculated as the negative log probability of that event happening in its given context. Applied to language, each word is an event, and the context is the sentence it appears in. Large language models, like GPT, provide a convenient way to calculate word probabilities in context.</p>
        <div id="equation">
          Surprisal(x) = -log<sub>2</sub> P(x | context)
        </div>
        <p>Coming back to our examples: in sentence 1, <em>cat</em> has a low surprisal value, because it appears in a sentence where talking about cats is very probable. In sentence 2, <em>cat</em> has a high surprisal value, because lawyers giving cats lawsuits is improbable.</p>

        <p>Surprisal is a fascinating way to measure how the human brain handles unpredictability in language. However, surprisal numbers aren't very intuitive to understand on their own. With the <strong>Surprisal Calculator WM 7±2</strong>, you can now input any sentence and hear its surprisal values translated to pitch intervals: a low pitch indicates low surprisal, and a high pitch indicates high surprisal.</p> 

        <div id="demo-wrapper">
          <div id="ex1_demo"> CLICK to hear sentence 1</div>
          <div id="ex2_demo"> CLICK to hear sentence 2</div>
        </div>

        <p>The decision to translate surprisal numbers to musical pitches was not arbitrary. A good, informative sentence is made from a blend of predictability (low surprisal) and spontaneity (high surprisal); the same could also be said of a good melody. We quickly bore of a sentence made only of repetitive, predictable words ("he said that he thought that she said that they think that…"), we also quickly bore of a melody made of the same note, repeated over and over again. The delicate balancing act of predictability and spontaneity that plays out in both language and music seems to hint at a shared cognitive architecture used in both forms of expression.</p>
        <h1 id="how-to-use-the-surprisal-calculator-wm-72">How to use the
        Surprisal Calculator WM 7±2</h1>
        <ul>
        <li><p>Type any sentence in, and press <code>compose</code> to hear its surprisal values.</p></li>
        <li><p>Use the calculator buttons to adjust instrument type, the LLM used to calculate probability scores, and the scale used to match surprisal numbers to pitches.</p></li>
        <li><p>Try typing the beginning of a sentence, then clicking keys on the keyboard. This will generate text with the surprisal values corresponding to the key pitch: experiment with what a very low surprisal or very high surprisal sentence sounds like. We suggest playing a common melody on the keyboard ("jingle bells" is a good candidate). Good melodies, which balance repetition with variety, tend to generate good sentences.</p></li></ul>
        
        <h1>Sources and Code</h1>
        <p><a href="https://github.com/wobblybits/surprisal">Github Repository</a></p>
        <p><a href="https://aclanthology.org/2023.tacl-1.82/">Testing the Predictions of Surprisal Theory in 11 Languages</a> (Wilcox et al., TACL 2023)</p>

        <p><a href="https://doi.org/10.1016/j.cognition.2007.05.006"> Expectation-based syntactic comprehension</a> (Levy, Cognition 2008)</p>
        <p><a href="https://doi.org/10.1002/j.1538-7305.1948.tb01338.x">A mathematical theory of communication</a> (Shannon, 1948)</p>

        <h1>Assets & Models</h1>
        <p><a href="https://huggingface.co/gpt2">GPT2</a>: The smallest (124M parameters) version of the official open-sourced GPT-2 models released from OpenAI.</p>
        <p><a href="https://huggingface.co/HuggingFaceTB/SmolLM-135M">SmolLM</a>: The smallest (135M parameters) of the three models in the SmolLM series of state-of-the-art small language models developed by the Hugging Face research team. These models are built on Cosmo-Corpus, a meticulously curated high-quality training dataset.</p>
        <p><a href="https://huggingface.co/crumb/nano-mistral">Nano Mistral</a>: A small (170M parameters) Mistral model built for general web text completion at extremely low resource use.</p>
        <p><a href="https://huggingface.co/Felladrin/Smol-Llama-101M-Chat-v1">Smol Llama</a>: A small (101M parameters) chat-tuned Llama model based on the work of Peter Szemraj and Vincent Haines.</p>
        <p><a href="https://huggingface.co/KingNish/Qwen2.5-0.5b-Test-ft">Qwen 2.5</a>: A compact yet powerful language model (494M parameters) trained on a subset of the Magpie 300k Database to answer a variety of questions</p>
        <p><a href="https://huggingface.co/google/flan-t5-small">Flan T5</a>: Google's super small (74M parameters)version of the Text-To-Text Transfer Transformer (T5) model, fine-tuned on more than 1000 additional tasks (and more languages!).</p>
        <p>Calculator display font is <a href="https://int10h.org/oldschool-pc-fonts/fontlist/font?portfolio_6x8#-">Portfolio 6x8</a> from the <a href="https://int10h.org/oldschool-pc-fonts/">Old School PC Fonts project</a></p>
        <p>Calculator button font is <a href="https://fonts.google.com/specimen/Fredoka">Fredoka</a> by <a href="https://milenabdesign.com/">Milena Brandão</a></p>
        <p>Instrument icons by <a href="https://www.flaticon.com/authors/ains">Ains</a> and <a href="https://www.flaticon.com/authors/iconpack">IconPack</a> at <a href="https://www.flaticon.com/">Flaticon</a></p>
        <p>Sounds generated with <a href="https://tonejs.github.io/">Tone.js</a></p>
        <p>Cat <a href="https://pixabay.com/sound-effects/cat-meow-8-fx-306184/">sound effect</a> by <a href="https://buymeacoffee.com/bfcmusic">bfcmusic</a></p>
    </div>
  </body>
</html>